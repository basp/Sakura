** LambdaMOO Database, Format Version 6 **
19
29
0
2
3
17
#0
System Object

16
3
-1
-1
-1
1
-1
4
1
do_login_command
3
173
-1
15
actor
action
nothing
ambiguous_match
failed_match
actions
ansi
creature
player
room
english_utils
string_utils
wiz
thing
root
16
1
4
3
1
1
5
3
1
1
-1
3
1
1
-2
3
1
1
-3
3
1
1
8
3
1
1
10
3
1
1
11
3
1
1
12
3
1
1
13
3
1
1
14
3
1
1
15
3
1
1
3
3
1
1
16
3
1
1
1
17
1
5
3
1
#1
Root Class

16
3
-1
-1
-1
-1
0
-1
7
name
3
173
-1
title
3
173
-1
dname
3
173
-1
iname
3
173
-1
dnamec
3
173
-1
inamec
3
173
-1
announce_action_text aat
17
173
-1
1
listening
1
0
0
3
1
#2
The First Room

0
3
-1
3
-1
13
-1
-1
1
eval
3
88
-2
0
1
5
3
1
#3
Wizard

7
3
2
-1
17
12
17
-1
0
0
6
5
3
1
4
0
3
1
0
1
3
1
0
156105512
3
1
4
0
3
1
5
3
1
#4
generic actor

0
3
-1
-1
-1
1
11
5
7
queue_action
3
165
-1
process_queue
3
165
-1
cancel_current_action
3
165
-1
fork_process_queue
3
165
-1
clear_queue
3
165
-1
qu*eue
3
29
-1
doing_msg
3
173
-1
4
queue
preemptible
process_queue
executing
5
4
0
3
1
0
1
3
1
0
886935895
3
1
4
0
3
1
5
3
1
#5
generic action

0
3
-1
-1
-1
1
6
8
2
_start
3
172
-1
_finish
3
172
-1
0
1
5
3
1
#6


0
3
-1
-1
-1
5
-1
7
0
0
1
5
3
1
#7
foo

0
3
-1
-1
-1
5
-1
-1
4
_start
3
172
-1
_finish
3
172
-1
_abort
3
173
-1
doing_msg
3
173
-1
0
1
5
3
1
#8
actions library

0
3
-1
-1
-1
1
-1
10
0
1
foo
2
1
7
3
1
5
3
1
#9 recycled
#10
ansi utils

0
3
-1
-1
-1
1
-1
13
0
20
esc
reset
bold_on
bold_off
black
red
green
yellow
blue
magenta
cyan
white
black_bg
red_bg
green_bg
yellow_bg
blue_bg
magenta_bg
cyan_bg
white_bg
21
2

3
1
2
[0m
3
1
2
[1m
3
1
2
[22m
3
1
2
[30m
3
1
2
[31m
3
1
2
[32m
3
1
2
[33m
3
1
2
[34m
3
1
2
[35m
3
1
2
[36m
3
1
2
[37m
3
1
2
[40m
3
1
2
[41m
3
1
2
[42m
3
1
2
[43m
3
1
2
[44m
3
1
2
[45m
3
1
2
[46m
3
1
2
[47m
3
1
5
3
1
#11
generic creature

0
3
-1
-1
-1
4
12
-1
2
tell
3
173
-1
say
17
173
-1
1
has_proper_name
6
0
0
3
1
5
3
1
5
3
1
5
3
1
5
3
1
5
3
1
#12
generic player

0
3
-1
-1
-1
11
3
-1
1
l*ook
17
93
-2
0
6
0
1
3
1
5
3
1
5
3
1
5
3
1
5
3
1
0
1
3
1
#13
generic room

0
3
-1
-1
-1
1
2
14
3
announce_all
3
173
-1
announce_all_but
3
173
-1
say
17
93
-2
0
1
5
3
1
#14
english utils

0
3
-1
-1
-1
1
-1
15
2
article_for
3
173
-1
quote
3
173
-1
0
1
5
3
1
#15
string utils

0
3
-1
-1
-1
1
-1
16
1
capitalize
3
173
-1
1
alphabet
2
2
abcdefghijklmnopqrstuvwxyz
3
1
5
3
1
#16
generic thing

0
3
-1
-1
-1
1
-1
-1
0
0
1
5
3
1
#17
Vanity

7
3
2
-1
-1
3
-1
-1
0
0
6
5
3
1
4
0
3
1
0
1
3
1
0
620873204
3
1
4
0
3
1
5
3
1
#18 recycled
#0:0
return #17;
.
#1:0
return this.name;
.
#1:1
return this:name();
.
#1:2
return tostr("the ", this:name());
.
#1:3
name = this:name();
if (has_property(this, "article"))
return tostr(this.article, " ", name);
endif
return tostr($english_utils:article_for(name), " ", name);
.
#1:4
return $string_utils:capitalize(this:dname());
.
#1:5
return $string_utils:capitalize(this:iname());
.
#1:6
this.location:announce_all(@args);
.
#2:0
answer = eval(("return " + argstr) + ";");
if (answer[1])
notify(player, tostr("=> ", toliteral(answer[2])));
else
for line in (answer[2])
notify(player, line);
endfor
endif
.
#4:0
":queue_action(OBJ action, LIST args, BOOL int, STR cmd)";
{action, args, INT, cmd} = spec = args;
if (length(this.queue) > 25)
notify(player, tostr($ansi.cyan, "[ Sorry -- can't queue ", action.name, " (", cmd, "), more than 25 actions! ]", $ansi.reset));
return;
endif
this.queue = listappend(this.queue, spec);
if (task_valid(this.process_queue))
if (this.preemptible)
this:cancel_current_action();
else
notify(player, tostr($ansi.cyan, "[ queued '", cmd, "' ]", $ansi.reset));
endif
else
this:fork_process_queue();
endif
.
#4:1
":process_queue()";
continuation = {};
while (this.queue || continuation)
this.preemptible = 0;
if (continuation)
{action, args, INT, cmd} = spec = continuation;
startverb = "_continue";
continuation = {};
else
{action, args, INT, cmd} = spec = this.queue[1];
startverb = "_start";
this.queue = listdelete(this.queue, 1);
endif
this.executing = {@spec, 0};
try
result = action:(startverb)(this, args);
except e (ANY)
if (e[1] == E_NONE)
result = E_NONE;
else
result = E_INVARG;
endif
endtry
status = this.executing[5];
this.executing[5] = 1;
if (status in {2, 3})
this:cancel_current_action(status == 3);
elseif (typeof(result) != ERR)
{duration, pass_to_finish} = result;
suspend(duration);
if (has_callable_verb(action, "_finish"))
this.executing[5] = 4;
try
continuation = action:_finish(this, args, pass_to_finish);
except e (ANY)
if (e[1] != E_NONE)
"Notify someone or something of exception.";
endif
endtry
status = this.executing[5];
endif
endif
this.executing = {};
if (status in {2, 3})
"Something called the action while we were running _finish, so abort instead of queuing continuation.";
continuation = {};
endif
endwhile
this.preemptible = 1;
.
#4:2
":cancel_current_action([INT dontabort])";
{?dontabort = 0} = args;
if (this.executing)
if (this.executing[5] == 0)
"We are in _start, set a flag telling :process_queue to stop the action.";
this.executing[5] = 2 + dontabort;
return;
elseif (this.executing[5] in {2, 3})
"Already asked to abort, nothing to do...";
return;
elseif (this.executing[5] == 4)
"Doing _finish, so we can't really cancel now, but if it's a continuing action it might still want to do something.";
this.executing[5] = 2 + dontabort;
return;
elseif (this.executing[5] == 1)
"We are between _start and _finish, cancel and move on.";
if ((!dontabort) && has_callable_verb(this.executing[1], "_abort"))
this.executing[1]:_abort(this, @this.executing[2..4]);
endif
this.executing = {};
"It is intentional that this case doesn't return.";
endif
old_pq = this.process_queue;
if (this.queue)
"Calling with a 1 to force it.";
this:fork_process_queue(1);
endif
if (task_valid(old_pq))
kill_task(old_pq);
endif
endif
.
#4:3
":fork_process_queue()";
force = args ? args[1] | 0;
if ((!force) && task_valid(this.process_queue))
return;
endif
fork pq_task (0)
this:process_queue();
endfork
this.process_queue = pq_task;
this.preemptible = 0;
this.executing = {};
.
#4:4
":clear_queue()";
this.queue = {};
this:cancel_current_action(1);
this.preemptible = 1;
.
#4:5
if (dobjstr && player.programmer)
if (!valid(dobj))
player:tell("queue who?");
return;
endif
if (!is_a(dobj, $actor))
player:tell("You can't queue that.");
endif
player:tell("Showing queue for ", toliteral(dobj), ":");
else
dobj = this;
endif
if ((!dobj.queue) && (!dobj.executing))
player:tell("You've got nothing to do.");
else
if (dobj.executing)
player:tell("At the moment, you're ", dobj:doing_msg(), ".");
endif
for x in (dobj.queue)
player:tell("  --> ", x[4]);
endfor
player:tell("  --> (end of queue)");
endif
.
#4:6
if (this.executing)
if (is_a(this.executing[1], $action))
return this.executing[1]:(verb)(this, this.executing[2]);
endif
return "";
endif
.
#7:0
who = args[1];
player:aat(who:name(), " starts fooing.");
return {3, 0};
.
#7:1
who = args[1];
player:aat(who:name(), " finishes fooing.");
.
#7:2
who = args[1];
player:aat(who:name(), " stops fooing.");
.
#7:3
return "fooing";
.
#11:0
notify(this, tostr(@args));
.
#11:1
txt = args[1] || "...";
m = $english_utils:quote(this, txt);
this:announce_action_text(m);
.
#12:0
if (!valid(player.location))
player:tell("There is only darkness.");
elseif (valid(dobj))
player:tell("It's ", dobj:iname(), ".");
elseif (dobjstr)
player:tell("There's no '", dobjstr, "' here.");
else
player:tell(player.location:name());
endif
.
#13:0
for x in (this.contents)
`x.listening ! ANY => 0' && x:tell(@args);
endfor
.
#13:1
":announce_all_but(LIST objects_to_ignore, text)";
{ignore, @text} = args;
contents = this.contents;
for x in (ignore)
contents = setremove(contents, x);
endfor
for x in (contents)
`x.listening ! ANY => 0' && x:tell(@text);
endfor
.
#13:2
player:say(argstr);
.
#14:0
":article_for(STR s)";
string = args[1];
if (!string)
return "a";
endif
for i in [1..length(string)]
if (index($string_utils.alphabet, string[i]))
if (index("aeiou", string[i]))
return "an";
else
return "a";
endif
endif
endfor
return "a";
.
#14:1
":quote(OBJ who, STR text, [BOOL real_name, [STR override_name]]) => 'Who says, \"text\".'";
{who, text} = args;
name = who:title();
if (text)
if (text[$] == "?")
return tostr(name, " asks, \"", text, "\"");
elseif (text[$] == "!")
return tostr(name, " exlaims, \"", text, "\"");
else
return tostr(name, " says, \"", text, "\"");
endif
else
return name;
endif
.
#15:0
":capitalize(STR string)";
if (string = args[1])
ansi = 0;
for i in [1..length(string)]
if (string[i] == "~")
ansi = 1;
elseif (ansi && (string[i] == "m"))
ansi = 0;
elseif (!ansi)
if (testi = index("abcdefghijklmnopqrstuvwxyz", string[i], 0))
string[i] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[testi];
return string;
endif
endif
endfor
return string;
endif
.
0 clocks
0 queued tasks
0 suspended tasks
1 active connections with listeners
17 0
